import socket
import random
import queue
import threading
import time
import logging


SEG_SYN = 0x00000001
SEG_ACK = 0x00000002
SEG_DATA = 0x00000004
SEG_FIN = 0x00000008

STAT_CLOSED = 0
STAT_LISTEN = 1
STAT_SYN_SENT = 2
STAT_SYN_RCVD = 3
STAT_ESTABLISHED = 4
STAT_CLOSE_WAIT = 5
STAT_LAST_ACK = 6
STAT_FIN_WAIT_1 = 7
STAT_FIN_WAIT_2 = 8
STAT_CLOSING = 9
STAT_TIME_WAIT = 10

UNRCVD_TAG = -1


class STPSocket:
    def __init__(self, mws, mss, gamma):
        self.udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.peer_addr = ("host", "port")
        self.mws = mws
        self.mss = mss
        self.gamma = gamma

        self.timeout_ms = 500 + gamma * 250
        self.timers = {}

        self.seq_num = 0
        self.peer_ack_num = 0
        self.ack_num = 0
        self.peer_seq_num = 0

        self.window = mws

        self.peer_seq_num = 0

        self.PLD = None

        self.status = STAT_CLOSED
        self.recv_queue = queue.Queue()
        self.recv_thread = threading.Thread(target=self.__recv_thread_func)

        self.recv_buf = []
        self.sent_segs = {}

        self.logger = logging.getLogger("stp")
        self.logger.setLevel(logging.INFO)
        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter(fmt="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        ch.setFormatter(formatter)
        self.logger.addHandler(ch)

    def __timer_callback(self, seq):
        self.logger.warning("seq %d ACK timeout" % (seq))

        seg = self.sent_segs[seq]
        self.PLD.send(seg.to_byte(), self.peer_addr)
        # self.udp_socket.sendto(seg.to_byte(), self.peer_addr)

        self.timers[seq] = Timer(self.timeout_ms, self.__timer_callback, seq)
        self.timers[seq].start()
        self.logger.warning("Sending Time out, set retransmit")

    def __recv_thread_func(self):
        self.logger.info("Recv thread start")
        while self.status != STAT_CLOSED:
            data, peer_addr = self.udp_socket.recvfrom(self.mws + 4 * 5)
            if self.peer_addr == ("host", "port"):
                self.peer_addr = peer_addr

            seg = Segment()
            seg.from_byte(data)

            if seg.flag & SEG_ACK:
                self.is_reack = self.peer_ack_num == seg.ack_num
                if self.is_reack:
                    self.logger.warning("Got same ACK, seg ack: " + str(seg.ack_num))

            self.peer_seq_num = seg.sequence_num
            self.peer_ack_num = seg.ack_num

            if self.status == STAT_LISTEN:
                self.__listen_handler(seg)
            elif self.status == STAT_SYN_RCVD:
                self.__syn_rcvd_handler(seg)
            elif self.status == STAT_SYN_SENT:
                self.__syn_sent_handler(seg)
            elif self.status == STAT_ESTABLISHED:
                self.__established_handler(seg)
            elif self.status == STAT_FIN_WAIT_1:
                self.__fin_wait_1_handler(seg)
            elif self.status == STAT_FIN_WAIT_2:
                self.__fin_wait_2_handler(seg)
            elif self.status == STAT_CLOSE_WAIT:
                self.__close_wait_handler(seg)
            elif self.status == STAT_LAST_ACK:
                self.__last_ack_handler(seg)
            else:
                self.status = STAT_CLOSED

        self.logger.info("Recv thread exit")

    def __syn_sent_handler(self, recv_seg):
        if self.status != STAT_SYN_SENT:
            return False
        self.logger.info("STP change to SYN_SENT")

        if recv_seg.flag == SEG_SYN | SEG_ACK: # and recv_seg.ack_num == self.seq_num:
            self.ack_num = self.peer_seq_num + 1
            ack_seg = Segment(self.seq_num, self.ack_num, SEG_ACK, self.window)
            self.udp_socket.sendto(ack_seg.to_byte(), self.peer_addr)
            self.logger.info("SYN_SENT sent ACK seg")
            self.status = STAT_ESTABLISHED
        return True

    def __listen_handler(self, recv_seg):
        if self.status != STAT_LISTEN:
            return False
        self.logger.info("STP change to LISTEN")

        if recv_seg.flag == SEG_SYN:
            self.ack_num = self.peer_seq_num + 1
            acksyn_seg = Segment(self.seq_num, self.ack_num, SEG_SYN | SEG_ACK, self.window)
            self.udp_socket.sendto(acksyn_seg.to_byte(), self.peer_addr)

            self.logger.info("LISTEN sent ACK|SYN seg")
            self.status = STAT_SYN_RCVD
            self.seq_num += 1
        return True

    def __syn_rcvd_handler(self, recv_seg):
        if self.status != STAT_SYN_RCVD:
            return False
        self.logger.info("STP change to SYN_RCVD")

        if recv_seg.flag == SEG_ACK and recv_seg.ack_num == self.seq_num:
            self.status = STAT_ESTABLISHED

        return True

    def __established_handler(self, recv_seg):
        if self.status != STAT_ESTABLISHED:
            return False
        self.logger.debug("STP ESTABLISHED")

        if recv_seg.flag == SEG_DATA:

            # 错误到达
            if not recv_seg.is_completed:
                self.udp_socket.sendto(Segment(self.seq_num, self.ack_num, SEG_ACK, self.window).to_byte(),
                                       self.peer_addr)
                self.logger.warning("Got corr data seg")
                return True

            if len(self.recv_buf) < recv_seg.sequence_num - 1 + len(recv_seg.payload):
                for i in range(recv_seg.sequence_num - 1 + len(recv_seg.payload) - len(self.recv_buf)):
                    self.recv_buf.append(UNRCVD_TAG)

            for i in range(len(recv_seg.payload)):
                if self.recv_buf[i + recv_seg.sequence_num - 1] == UNRCVD_TAG:
                    self.recv_buf[i + recv_seg.sequence_num - 1] = recv_seg.payload[i]
                else:
                    self.logger.warning("dup data. seq: " + str(recv_seg.sequence_num))
                    break

#           # 非重复到达或乱序到达
#           if self.ack_num == recv_seg.sequence_num:
#               self.ack_num += len(recv_seg.payload)
            for i in range(len(self.recv_buf)):
                if i == len(self.recv_buf) - 1 or self.recv_buf[i + 1] == UNRCVD_TAG:
                    self.ack_num = i + 1 + 1
                    break

            self.logger.info("sending ACK. stp ack_num: %d, seg seg_num: %d" % (self.ack_num, recv_seg.sequence_num))

            self.udp_socket.sendto(Segment(self.seq_num, self.ack_num, SEG_ACK, self.window).to_byte(),
                                   self.peer_addr)

        elif recv_seg.flag == SEG_ACK:
            # 根据recv.seg.ack_num更新窗口
            # 如果这是重复的ACK，且窗口小于于分段大小
            #   设置重传标志

            self.logger.info("got ACK. seg ack_num: %d, stp seg_num: %d" % (recv_seg.ack_num, self.seq_num))

            self.window = self.mws - (self.seq_num - recv_seg.ack_num)
            for key in self.timers.keys():
                if key <= recv_seg.ack_num:
                    self.timers[key].pause()

            if self.is_reack and self.window < self.mss:
                last_acked_seg = self.sent_segs[self.peer_ack_num]
                seg = self.sent_segs[self.peer_ack_num + len(last_acked_seg.payload)]
                self.logger.warning("Fast retransmit seg: " + str(seg.sequence_num))
                self.PLD.send(seg.to_byte(), self.peer_addr)

        elif recv_seg.flag == SEG_FIN:
            self.logger.info("Recv a FIN")
            self.ack_num = self.peer_seq_num + 1
            ack_seg = Segment(self.seq_num, self.ack_num, SEG_ACK, self.window)
            self.udp_socket.sendto(ack_seg.to_byte(), self.peer_addr)
            self.status = STAT_CLOSE_WAIT
            self.__close_wait_handler(None)

        return True

    def __fin_wait_1_handler(self, recv_seg):
        if self.status != STAT_FIN_WAIT_1:
            return False

        self.logger.info("STP change to FIN_WAIT_1")
        if recv_seg.flag == SEG_ACK and recv_seg.ack_num == self.seq_num:
            self.status = STAT_FIN_WAIT_2

        return True

    def __fin_wait_2_handler(self, recv_seg):
        if self.status != STAT_FIN_WAIT_2:
            return False
        self.logger.info("STP change to FIN_WAIT_2")

        if recv_seg.flag == SEG_FIN:
            self.ack_num = self.peer_seq_num + 1
            ack_seg = Segment(self.seq_num, self.ack_num, SEG_ACK, self.window)
            self.udp_socket.sendto(ack_seg.to_byte(), self.peer_addr)
            self.status = STAT_CLOSED

        return True

    def __close_wait_handler(self, recv_seg):
        if self.status != STAT_CLOSE_WAIT:
            return False
        self.logger.info("STP change to CLOSE_WAIT")

        syn_seg = Segment(self.seq_num, self.ack_num, SEG_FIN, self.window)
        self.udp_socket.sendto(syn_seg.to_byte(), self.peer_addr)
        self.seq_num += 1
        self.status = STAT_LAST_ACK

        return True

    def __last_ack_handler(self, recv_seg):
        if self.status != STAT_LAST_ACK:
            return False
        self.logger.info("STP change to LAST_ACK")

        if recv_seg.flag == SEG_ACK and recv_seg.ack_num == self.seq_num:
            self.status = STAT_CLOSED

        return True

    def connect(self, host, port):
        # Send SYN and change status to SYN_SENT
        self.status = STAT_SYN_SENT
        self.recv_thread.start()

        self.seq_num = 0
        self.ack_num = 0
        self.window = self.mws

        self.peer_addr = (host, port)

        syn_seg = Segment(self.seq_num, self.ack_num, SEG_SYN, self.window)
        self.udp_socket.sendto(syn_seg.to_byte(), self.peer_addr)
        self.logger.info("Connect. Sent SYN seg")
        self.seq_num += 1

        while self.status != STAT_ESTABLISHED:
            pass    # TODO should sleep

    def bind(self, host, port):
        self.udp_socket.bind((host, port))

    def listen(self):
        self.seq_num = 0
        self.ack_num = 0
        self.window = self.mws

        self.status = STAT_LISTEN

    def accept(self):
        if self.status != STAT_LISTEN:
            return False

        self.recv_thread.start()

        while self.status != STAT_ESTABLISHED:
            pass    # TODO should sleep

    def close(self):
        if self.status != STAT_ESTABLISHED:
            return

        syn_seg = Segment(self.seq_num, self.ack_num, SEG_FIN, self.window)
        self.udp_socket.sendto(syn_seg.to_byte(), self.peer_addr)
        self.logger.info("Close. Sent FIN seg")
        self.seq_num += 1

        self.status = STAT_FIN_WAIT_1

    def set_pld(self, p_drop, p_duplicate, p_corrupt, p_order, max_order, p_delay, max_delay, seed):
        self.PLD = PLD(p_drop, p_duplicate, p_corrupt, p_order, max_order, p_delay, max_delay, seed, self.udp_socket)

    def recv(self, buf_size):
        while len(self.recv_buf) == 0:
            pass

        result = bytes(self.recv_buf)

        self.recv_buf.clear()

        return result

    def send(self, buf):
        i = 0

        while i < len(buf):
            seg_len = min(self.mss, len(buf) - i)
            # 当窗口大于segment大小时
            if self.window >= seg_len:
                # 发送
                self.window = self.mws - (self.seq_num - self.peer_ack_num) - seg_len

                self.logger.info("send seg. seq: %d, window: %d" % (self.seq_num, self.window))

                seg = Segment(self.seq_num, self.ack_num, SEG_DATA, self.window, buf[i: i + seg_len])

                self.timers[self.seq_num + seg_len] = Timer(self.timeout_ms, self.__timer_callback, self.seq_num + seg_len)
                self.timers[self.seq_num + seg_len].start()
                self.sent_segs[self.seq_num + seg_len] = seg

                self.PLD.send(seg.to_byte(), self.peer_addr)
                # self.udp_socket.sendto(seg.to_byte(), self.peer_addr)

                self.seq_num += seg_len

                i += seg_len
                continue

            # 等待窗口恢复
            self.window = self.mws - (self.seq_num - self.peer_ack_num)
            while self.window < seg_len:
                pass


class Segment:
    def __init__(self, sequence_num=0, ack_num=0, flag=0, window=0, payload=b''):
        self.sequence_num = sequence_num
        self.ack_num = ack_num
        self.flag = flag
        self.window = window
        self.checksum = 0
        self.payload = payload

        self.is_completed = False

    def set_payload(self, payload):
        self.payload = b''
        self.payload += payload

    def calc_checksum(self):
        self.checksum = self.sequence_num + self.ack_num + self.flag + self.window
        for i in range(0, len(self.payload), 4):
            if i + 4 < len(self.payload):
                tmp = self.payload[i: i + 4]
            else:
                tmp = self.payload[i:]
                for j in range(4 - (len(self.payload) - i)):
                    tmp += b'\x00'

            self.checksum += int.from_bytes(tmp, byteorder='big', signed=False) % 0xffffffff

    def to_byte(self):
        self.calc_checksum()

        data = self.sequence_num.to_bytes(4, 'big', signed=False)
        data += self.ack_num.to_bytes(4, 'big', signed=False)
        data += self.flag.to_bytes(4, 'big', signed=False)
        data += self.window.to_bytes(4, 'big', signed=False)
        data += self.checksum.to_bytes(4, 'big', signed=False)
        data += self.payload
        return data

    def from_byte(self, data):
        self.sequence_num = int.from_bytes(data[0:4], byteorder='big', signed=False)
        self.ack_num = int.from_bytes(data[4:8], byteorder='big', signed=False)
        self.flag = int.from_bytes(data[8:12], byteorder='big', signed=False)
        self.window = int.from_bytes(data[12:16], byteorder='big', signed=False)
        self.payload = data[20:]

        checksum = int.from_bytes(data[16:20], byteorder='big', signed=False)
        self.calc_checksum()

        self.is_completed = checksum == self.checksum
        return checksum == self.checksum


class PLD:
    def __init__(self, p_drop, p_duplicate, p_corrupt, p_order, max_order, p_delay, max_delay, seed, udp_sock):
        self.p_drop = p_drop
        self.p_duplicate = p_duplicate
        self.p_corrupt = p_corrupt
        self.p_order = p_order
        self.max_order = max_order
        self.p_delay = p_delay
        self.max_delay = max_delay

        self.udp_sock = udp_sock

        random.seed(seed)

        self.logger = logging.getLogger("PLD")
        self.logger.setLevel(logging.INFO)
        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter(fmt="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        ch.setFormatter(formatter)
        self.logger.addHandler(ch)

        self.send_queue = queue.Queue()
        self.order_data = None
        self.order_counter = max_order

    def __send(self, buf, addr):
        self.send_queue.put((buf, addr))

        if self.order_data is not None:
            self.order_counter -= 1

        if self.order_counter == 0:
            self.send_queue.put(self.order_data)
            self.order_data = None

        self.flush()

    def send(self, buf, addr):
        # drop
        p = random.random()
        if p < self.p_drop:
            self.logger.info("drop")
            return

        # duplicate
        p = random.random()
        if p < self.p_duplicate:
            self.logger.info("duplicate")
            self.__send(buf, addr)
            self.__send(buf, addr)
            return

        # corrupt
        p = random.random()
        if p < self.p_corrupt:
            self.logger.info("corrupt")
            tmparr = list(buf)
            tmparr[0] = (tmparr[0] & 0xfe) | (~tmparr[0] & 0x01)    # 翻转第一个字节的第一位
            self.__send(bytes(tmparr), addr)
            return

        # order
        p = random.random()
        if p < self.p_order:
            self.logger.info("order")
            if self.order_data is None:
                self.order_data = (buf, addr)
                self.order_counter = self.max_order
            else:
                self.__send(buf, addr)
            return

        # delay
        p = random.random()
        if p < self.p_delay:
            self.logger.info("delay")
            t = self.max_delay * random.random() / 1000
            time.sleep(t)
            self.__send(buf, addr)
            return

        self.__send(buf, addr)
        return

    def flush(self):
        while not self.send_queue.empty():
            buf, addr = self.send_queue.get()
            self.udp_sock.sendto(buf, addr)


class Timer:
    def __init__(self, ms, callback, argv):
        self.__user_setting = ms
        self.__times = self.__user_setting / 50
        self.__callback = callback
        self.__argv = argv

        self.__status = 0
        self.__timer_thread = threading.Thread(target=self.__timer_func)

    def __timer_func(self):
        while self.__times > 0:
            time.sleep(0.05)
            if self.__status == 0:
                return
            else:
                self.__times -= 1

        self.__callback(self.__argv)

    def start(self):
        self.__status = 1

        self.__timer_thread = threading.Thread(target=self.__timer_func)
        self.__timer_thread.start()

    def pause(self):
        self.__status = 0

    def reset(self, ms=-1):
        if ms > 0:
            self.__user_setting = ms

        self.__times = self.__user_setting / 50


class Test:
    def __init__(self):
        self.timer = Timer(2000, self.timer_test, self)

    def timer_test(self, argv):
        print("alarm. time: %s, info: %s" % (str(time.time()), type(argv)))

    def test(self):
        print("Start time: " + str(time.time()))
        self.timer.start()

        time.sleep(1)

        print("Pause time: " + str(time.time()))
        self.timer.pause()

        time.sleep(2)

        print("restart time: " + str(time.time()))
        self.timer.start()


def main():
    test = Test()
    test.test()


if __name__ == '__main__':
    main()
